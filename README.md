# C++面向对象
## 内存模型
### 代码区
二进制代码 操作系统管理

存放CPU执行的机器指令 **机器指令=操作码+地址码**

**共享**-只有一份-省内存

**只读**-防止反编译大师恶意修改

### 全局区
全局变量（函数外部） 静态变量（static） 常量（指的是字符串常量）

**函数外部**的变量+static修饰的变量+字符串常量 ->全局区

**操作系统管理**
### 栈区
**编译器分配**

不能返回局部变量的指针的原因是：

局部变量在函数结束时被销毁，虽然可以取到他的地址，但是地址对应的数值却不是原来的

地址虽在，但是地址对应住的人换了

一个函数结束时才会销毁局部变量，main函数一般不会出现返回局部变量地址发生错误的问题，因为main函数是某个项目的唯一主函数

**解决方法是：1.static修饰  or  堆区开辟  or  ->跨越阶级才能保证生存！**


### 堆区
程序员分配
new int(1314);

上面这个是个指针

int *a = new int(1314);

return *a;
## 引用
**量子纠缠**

int a = 1314;

int &b = a;

绑定宿主后，不可更改

Applicaton：引用传递

形参如何修饰实参：值传递；指针传递；引用传递；

**不要返回函数的引用**

**可以返回全局变量的引用**

**返回类型是:引用 的函数 可以作为左值**

### 引用的本质->指针常量
int &ref = a ；<=>
int *const ref = &a;

这也就是宿主绑定后不可换宿主的原因；

锁死引用，不可修改值的操作：
const int& a；

防止a值被误操作
Application：void func(const int &val);

## 默认参数与重载
函数形参可以有默认值

函数声明有了默认参数，函数实现就不能有默认参数

只能有一次默认参数的机会，

### 函数占位参数
### 函数重载
函数默认参数和函数重载可能会发生冲突，一般不建议同时使用

## C++类和对象
### 封装：属性和服务打包在一起；
###    ：接口权限设置；
#### 类和对象：

struct 相当于基本类型（int double string 或者int *）的组合

类相当于高级的struct 


对象相当于类的实例
#### 实战

实战创建学生的类时，string类型的变量赋值要用"  "引起来；

否则会警告！










